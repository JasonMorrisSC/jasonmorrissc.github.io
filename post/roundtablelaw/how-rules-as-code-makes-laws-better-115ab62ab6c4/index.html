<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>How Rules as Code Makes Laws Better | Jason Morris</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Drafting the Rock Paper Scissors Act in s(CASP)">
<meta name=generator content="Hugo 0.92.0">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="How Rules as Code Makes Laws Better">
<meta property="og:description" content="Drafting the Rock Paper Scissors Act in s(CASP)">
<meta property="og:type" content="article">
<meta property="og:url" content="https://JasonMorrisSC.github.io/post/roundtablelaw/how-rules-as-code-makes-laws-better-115ab62ab6c4/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-05-15T15:15:51+00:00">
<meta property="article:modified_time" content="2021-05-15T15:15:51+00:00">
<meta itemprop=name content="How Rules as Code Makes Laws Better">
<meta itemprop=description content="Drafting the Rock Paper Scissors Act in s(CASP)"><meta itemprop=datePublished content="2021-05-15T15:15:51+00:00">
<meta itemprop=dateModified content="2021-05-15T15:15:51+00:00">
<meta itemprop=wordCount content="4984">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="How Rules as Code Makes Laws Better">
<meta name=twitter:description content="Drafting the Rock Paper Scissors Act in s(CASP)">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Jason Morris
</a>
<div class="flex-l items-center">
<ul class="pl0 mr3">
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/about/ title="About Jason page">
About Jason
</a>
</li>
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/project/ title="Projects page">
Projects
</a>
</li>
<li class="list f5 f4-ns fw4 dib pr3">
<a class="hover-white no-underline white-90" href=/post/ title="Rules as Code Diary page">
Rules as Code Diary
</a>
</li>
</ul>
<div class=ananke-socials>
<a href=https://twitter.com/RoundTableLaw target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:{{ .fill }}"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</span></a>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
RULES AS CODE DIARY
</aside>
<div id=sharing class="mt3 ananke-socials">
<a href="https://twitter.com/share?url=https://JasonMorrisSC.github.io/post/roundtablelaw/how-rules-as-code-makes-laws-better-115ab62ab6c4/&text=How%20Rules%20as%20Code%20Makes%20Laws%20Better" class="ananke-social-link twitter no-underline" aria-label="share on Twitter">
<span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:{{ .fill }}"/></svg>
</span>
</a>
</div>
<h1 class="f1 athelas mt3 mb1">How Rules as Code Makes Laws Better</h1>
<time class="f6 mv4 dib tracked" datetime=2021-05-15T15:15:51Z>May 15, 2021</time>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>I want to give you an intuition for why Rules as Code in logical tools like s(CASP) makes laws better.</p>
<p>Let’s imagine that you are the legal knowledge engineer assigned to the Rules as Code process for drafting the Rock Paper Scissors Act of 2021. The purpose of the Rock Paper Scissors Act is to set out the official rules of who is the winner of a game of Rock Paper Scissors.</p>
<h3 id=the-draft>The Draft</h3>
<p>We need to start with a proposed natural language draft of the law. So here is a first attempt that we can play with.</p>
<blockquote>
<p>1. The winner of a game of rock paper scissors is the player in the game who throws a sign that beats the sign of another player in the game.</p>
</blockquote>
<blockquote>
<p>2. Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.</p>
</blockquote>
<h3 id=the-procedure>The Procedure</h3>
<ol>
<li>Start small.</li>
<li>Check to see if your law behaves as expected.</li>
<li>If not, figure out why, and fix it.</li>
<li>If anything else needs to be added, start over at 1.</li>
<li>Do verification to learn how the rules behave.</li>
<li>If it behaves improperly, fix it.</li>
<li>If it behaves in ways that you can’t categorize as proper or improper, go back to the client for more instructions.</li>
</ol>
<p>I’m going to take you through 5 iterations of steps 1 through 4, and a little of step 5.</p>
<h3 id=first-iteration>First Iteration</h3>
<p>We are going to start super small. We’re going to start with the conclusion of rule 1, that a player wins a game, but we are going to start only with the requirement that the player is “in the game”.</p>
<p>For that we are going to need two terms in our vocabulary:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#pred</span> <span style=color:#a6e22e>player_in_game</span>(Player,Game) <span style=color:#e6db74>::</span> <span style=color:#e6db74>&#39;@(Player) participated in @(Game)&#39;</span>.  
<span style=color:#e6db74>#pred</span> <span style=color:#a6e22e>winner_of_game</span>(Player,Game) <span style=color:#e6db74>::</span> <span style=color:#e6db74>&#39;@(Player) is the winner of @(Game)&#39;</span>.
</code></pre></div><p>These <code>#pred</code> statements tell s(CASP) how to translate your code back into English once s(CASP) has turned your rules and your facts into an answer and an explanation.</p>
<p>Now we need our rule, that a person is the winner of a game if they are a player in that game.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game).
</code></pre></div><p>Now if we want to test our rule, could create some data. But that would very quickly get onerous as the rule gets more complex. To test it completely, we would need to create a different test for each possible combination of inputs.</p>
<p>Instead, we are going to tell s(CASP) that it should just consider both the possibility that a statement is true, and the possibility that a statement is false. We do that with an <code>#abducible</code> statement, like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>player_in_game</span>(Player,Game).
</code></pre></div><p>Note that we don’t want s(CASP) to hypothesize about <code>winner_of_game</code>, because that is the question that we are going to be asking to see if the code works, right now.</p>
<p>Now we have enough to run our first test, so we ask s(CASP) to describe all of the ways in which a game might be won by posing this query:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>winner_of_game</span>(Player,Game).
</code></pre></div><p>When I say we run a query, what I mean is that you put all of the above text into a file, give it a name like <code>rps.pl</code>, and then run the command <code>scasp rps.pl --human --tree -s0</code> . That tells s(CASP) to load that file, execute the query it includes, find all the answers it can, and explain them in English.</p>
<p>When we run that command, we get the following output:</p>
<pre tabindex=0><code>QUERY:I would like to know if  
     Player is the winner of Game.

JUSTIFICATION_TREE:  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game
</code></pre><p>(Note: I’m editing a lot of extraneous information from the output to make it more readable.)</p>
<p>So the explanation is “Player is the winner of Game, because Player participated in Game, because that is assumed.” There is only one answer, so there is only one way to be the winner of game. So that matches what we were expecting.</p>
<p>Congratulations. We have finished our first iteration, and we will move on to adding something else.</p>
<h3 id=second-iteration>Second Iteration</h3>
<p>According to section 1 of our draft, in order to be the winner of a game, you have to throw a sign. So let’s add that as a piece of vocabulary:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#pred</span> <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign) <span style=color:#e6db74>::</span> <span style=color:#e6db74>&#39;@(Player) threw @(Sign)&#39;</span>.
</code></pre></div><p>Now we will modify the rule to require you to throw a sign.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign).
</code></pre></div><p>And we will tell s(CASP) that it can just make assumptions about whether or not a player threw a sign, this way:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign).
</code></pre></div><p>If we run the query again, we get one possible answer:</p>
<pre tabindex=0><code>Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw Var2, because  
        it is assumed that Player threw Var2
</code></pre><p>If we are getting one answer, you might wonder how many scenarios did s(CASP) consider? At this point, the answer is four. We have given it two abducibility statements, each of which creates two possibilities, either the statement is true, or the statement is false. Two statements, with two possibilities each, gives four scenarios. And in only one of those scenarios was it true that there was a winner of a game.</p>
<h3 id=third-iteration>Third Iteration</h3>
<p>Next let’s add the idea from section 1 of the draft that in order to win a game, your sign has to beat another player’s sign.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#pred</span> <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign) <span style=color:#e6db74>::</span> <span style=color:#e6db74>&#39;@(Sign) beats @(OtherSign)&#39;</span>.
</code></pre></div><p>And we can update the rule:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign),  
  <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign).
</code></pre></div><p>We can also add an abducibility statement about whether or not one sign beats another sign.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign).
</code></pre></div><p>s(CASP) is now considering 8 scenarios, but there is still only one answer to our query:</p>
<pre tabindex=0><code>Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw Var2, because  
        it is assumed that Player threw Var2  
    Var2 beats Var3, because  
        it is assumed that Var2 beats Var3
</code></pre><p>So that is still behaving as expected. You might wonder why, if we called it “Sign” and “OtherSign” in the rule, does s(CASP) turn those names into “Var2” and “Var3” in the explanation? The reason is that the explanation is only aware of the variable names that are in your query. The variable names in the rules are invisible to it.</p>
<h3 id=fourth-iteration>Fourth Iteration</h3>
<p>This time, let’s add section 2.</p>
<p>For this, we don’t need to add any vocabulary, or any rules, or any abduction statements. Here, we just need to add three facts.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>sign_beats_sign</span>(<span style=color:#e6db74>rock</span>,<span style=color:#e6db74>scissors</span>).  
<span style=color:#a6e22e>sign_beats_sign</span>(<span style=color:#e6db74>scissors</span>,<span style=color:#e6db74>paper</span>).  
<span style=color:#a6e22e>sign_beats_sign</span>(<span style=color:#e6db74>paper</span>,<span style=color:#e6db74>rock</span>).
</code></pre></div><p>Because we don’t want anything else to be possible, we will also delete the line that makes <code>sign_beats_sign</code> abducible, so that only these three facts will be available to satisfy that requirement in section 1.</p>
<p>What do you think will happen if we run the query?</p>
<pre tabindex=0><code>QUERY:I would like to know if  
     Player is the winner of Game.

ANSWER: 1  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw rock, because  
        it is assumed that Player threw rock

ANSWER: 2  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw scissors, because  
        it is assumed that Player threw scissors

ANSWER: 3  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw paper, because  
        it is assumed that Player threw paper
</code></pre><p>There are now three ways to win a game, one for each of the possible signs that the winner can throw. Makes sense, right?</p>
<h3 id=an-aside>An Aside</h3>
<p>Let’s take a second here to notice what just happened. We have encoded part of section 1, and all of section 2. If you read our code for section 1, we did not need to convert section 1 into an algorithm, or a function, or an object, or anything else. Section 1 was originally written as a rule in English, and we just made it a rule written in s(CASP).</p>
<p>Likewise, section 2 is stating facts that are always true, and can be used while trying to figure out the implications of the other sections of the draft act. And when we translated it we just re-wrote the facts in s(CASP).</p>
<p>We didn’t have to change the form, just the language.</p>
<p>Why is that possible, and why is it important?</p>
<p>It’s possible because s(CASP) has an underlying semantics of formal logic, and <em>so does law</em>.</p>
<blockquote>
<p>If you already have natural language rules you are encoding, or you need to write natural language rules to match an encoding, your job is much easier when you use a computer language that is based on logic.</p>
</blockquote>
<p>It is important for a lot of reasons, but one major reason is how simple it is to turn rules into an application.</p>
<p>Look at how much work we did, after we had translated the rules, to be able to learn what the computer thought the rules meant.</p>
<p>We wrote <em>three lines of code.</em></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign).  
<span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>player_in_game</span>(Player,Game).  
<span style=color:#e6db74>?-</span> <span style=color:#a6e22e>winner_of_game</span>(Player,Game).
</code></pre></div><p>In fact, you can translate those lines of code, back into English, too. “Assuming that a player may or may not have thrown any particular sign, and assuming that a player may or may not be a participant in a game, under what possible scenarios is it true that a player won the game?”</p>
<blockquote>
<p>It is <em>also easier</em> to translate questions, facts, and even uncertainty about facts into logical programming languages, the combination of which turn your rules into an application.</p>
</blockquote>
<p>Logical programming languages make it easier to use laws, and facts, and questions, as the source code for applications.</p>
<h3 id=fifth-iteration>Fifth Iteration</h3>
<p>Let’s add the requirement from section 1 that there actually be a “sign of the other player” to beat. We just modify the rule to read like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign),  
  <span style=color:#a6e22e>player_in_game</span>(OtherPlayer,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(OtherPlayer,OtherSign),  
  <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign).
</code></pre></div><p>What should we see? Well, each of the three possibilities should now include another player, and what the other player threw should be the thing that is beaten by what the winner threw. Let’s see what happens:</p>
<pre tabindex=0><code>QUERY:I would like to know if  
     Player is the winner of Game.

ANSWER: 1  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw rock, because  
        it is assumed that Player threw rock  
    Var2 participated in Game, because  
        it is assumed that Var2 participated in Game  
    Var2 threw scissors, because  
        it is assumed that Var2 threw scissors

ANSWER: 2  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw scissors, because  
        it is assumed that Player threw scissors  
    Var2 participated in Game, because  
        it is assumed that Var2 participated in Game  
    Var2 threw paper, because  
        it is assumed that Var2 threw paper

ANSWER: 3  
Player is the winner of Game, because  
    Player participated in Game, because  
        it is assumed that Player participated in Game  
    Player threw paper, because  
        it is assumed that Player threw paper  
    Var2 participated in Game, because  
        it is assumed that Var2 participated in Game  
    Var2 threw rock, because  
        it is assumed that Var2 threw rock
</code></pre><p>It works! If “Player” threw paper, “Var2” threw rock, etc.</p>
<h3 id=a-wrinkle-or-two>A Wrinkle or Two</h3>
<p>These answers are a little deceptive, because Player and Var2 are variables with different names. But using different variable names in s(CASP) doesn’t imply that the things they refer to are different things.</p>
<p>What happens if we change the abduction rules so that the only thing we can assume about which players threw which sign is that “bob” threw something?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>player_threw_sign</span>(<span style=color:#e6db74>bob</span>,Sign).
</code></pre></div><p><code>bob</code>, because it is lower-case, refers to a specific thing, and anywhere you use <code>bob</code> across any rules and facts it always refers to the same thing. <code>Sign</code> , because it is upper case, is a variable, and can refer to anything.</p>
<p>So how many ways of winning should there be if there is only possibly one player, named bob? How many answers do we expect?</p>
<p>Perhaps surprisingly, the answer is still three! Let’s take a look at the first explanation to see why.</p>
<pre tabindex=0><code>bob is the winner of Game, because  
    bob participated in Game, because  
        it is assumed that bob participated in Game  
    bob threw rock, because  
        it is assumed that bob threw rock  
    bob participated in Game, because  
        it is assumed that bob participated in Game  
    bob threw scissors, because  
        it is assumed that bob threw scissors
</code></pre><p>So s(CASP) was considering a situation where a player beat themselves because they were the <code>Player</code>, <em>and</em> they were the <code>OtherPlayer</code>, and they threw two different signs!</p>
<p>That’s clearly not what we wanted. Again, inside a rule, using the same variable name twice means you are referring to the same thing. But, using different variable names does not mean that you are referring to different things. So even if you use the names “Player” and “OtherPlayer” you might be referring to the same thing twice. In this case, “bob”.</p>
<h4 id=making-disunity-explicit>Making Disunity Explicit</h4>
<p>So let’s add a line to the rule that actually imposes the condition “Player and OtherPlayer should not be the same thing.” In logical language, that’s called a “disunity”, and it is expressed in s(CASP) with the <code>\=</code> operator.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign),  
  <span style=color:#a6e22e>player_in_game</span>(OtherPlayer,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(OtherPlayer,OtherSign),  
  <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign),  
  Player <span style=color:#e6db74>\=</span> OtherPlayer.
</code></pre></div><p>Note that we are not adding anything to what is written in section 1 of the draft. The the semantic meaning of “another player” in section 1 is that it should be a distinct entity from the “player”. We’re just translating that implied semantic meaning into s(CASP).</p>
<p>Now, we should get zero models, because we have told s(CASP) that it is only allowed to assume that “bob” threw signs. And if we run the same query again, that’s what happens!</p>
<p>Now if we change the abducibility statement back to the line below, we would like to be getting three answers again.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#abducible</span> <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign).
</code></pre></div><p>But if we make that change and run the code, we still get zero models. Why is that?</p>
<p>Essentially, it’s because s(CASP) can’t do disunity across abducible entities in the conditions of a rule. I’m genuinely not sure why, because it does seem to be able do disunity across abducible entities in a query. But no worries, there’s a relatively easy workaround.</p>
<h4 id=quickly-generating-instances>Quickly Generating Instances</h4>
<p>Create a file called <code>example.pl</code> and include the following:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>example</span>(<span style=color:#ae81ff>0</span>).  
<span style=color:#a6e22e>example</span>(<span style=color:#ae81ff>1</span>).  
<span style=color:#a6e22e>example</span>(<span style=color:#ae81ff>2</span>).  
... 
</code></pre></div><p>continuing for as long as you need. Now in we can include that code in our program by adding a line like this at the top.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#include</span> <span style=color:#e6db74>&#39;example.pl&#39;</span>.
</code></pre></div><p>Now we can create a way to quickly say “for testing purposes, create X objects of this type” by adding this rule to our code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>player</span>(<span style=color:#a6e22e>test_player</span>(X)) :- <span style=color:#a6e22e>example</span>(X), <span style=color:#a6e22e>number_of_players</span>(N), X .<span style=color:#e6db74>&lt;.</span> N.
</code></pre></div><p>Now, we can add a single fact, right above our query in the code, which reads:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>number_of_players</span>(<span style=color:#ae81ff>2</span>).
</code></pre></div><p>That will create two players in every scenario, <code>test_player(0)</code> and <code>test_player(1)</code> . And if you want to change the number of players that you are testing against, you just change that one line before you run your query.</p>
<p>We now need to modify our rule to include the fact that both “Player” and “OtherPlayer” refer to a specific player entity, as follows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>player</span>(Player),  
  <span style=color:#a6e22e>player</span>(OtherPlayer),  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign),  
  <span style=color:#a6e22e>player_in_game</span>(OtherPlayer,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(OtherPlayer,OtherSign),  
  <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign),  
  Player <span style=color:#e6db74>\=</span> OtherPlayer.
</code></pre></div><p>We can also add the term <code>player</code> to our vocabulary, like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>#pred</span> <span style=color:#a6e22e>player</span>(X) <span style=color:#e6db74>::</span> <span style=color:#e6db74>&#39;@(X) is a player&#39;</span>.
</code></pre></div><p>Now we can run our query again, and we might expect to get three results again.</p>
<p>But what we actually get is 6!</p>
<p>Now what!?</p>
<pre tabindex=0><code>QUERY:I would like to know if  
     Player is the winner of Game.

ANSWER: 1  
test_player(0) is the winner of Game, because  
    test_player(0) is a player, because  
        'example' holds (for 0).  
    test_player(1) is a player, because  
        'example' holds (for 1).  
    test_player(0) participated in Game, because  
        it is assumed that test_player(0) participated in Game  
    test_player(0) threw rock, because  
        it is assumed that test_player(0) threw rock  
    test_player(1) participated in Game, because  
        it is assumed that test_player(1) participated in Game  
    test_player(1) threw scissors, because  
        it is assumed that test_player(1) threw scissors  
    rock beats scissors.

ANSWER: 2  
test_player(0) is the winner of Game, because  
    test_player(0) is a player, because  
        'example' holds (for 0).  
    test_player(1) is a player, because  
        'example' holds (for 1).  
    test_player(0) participated in Game, because  
        it is assumed that test_player(0) participated in Game  
    test_player(0) threw scissors, because  
        it is assumed that test_player(0) threw scissors  
    test_player(1) participated in Game, because  
        it is assumed that test_player(1) participated in Game  
    test_player(1) threw paper, because  
        it is assumed that test_player(1) threw paper  
    scissors beats paper.

ANSWER: 3  
test_player(0) is the winner of Game, because  
    test_player(0) is a player, because  
        'example' holds (for 0).  
    test_player(1) is a player, because  
        'example' holds (for 1).  
    test_player(0) participated in Game, because  
        it is assumed that test_player(0) participated in Game  
    test_player(0) threw paper, because  
        it is assumed that test_player(0) threw paper  
    test_player(1) participated in Game, because  
        it is assumed that test_player(1) participated in Game  
    test_player(1) threw rock, because  
        it is assumed that test_player(1) threw rock  
    paper beats rock.

ANSWER: 4  
test_player(1) is the winner of Game, because  
    test_player(1) is a player, because  
        'example' holds (for 1).  
    test_player(0) is a player, because  
        'example' holds (for 0).  
    test_player(1) participated in Game, because  
        it is assumed that test_player(1) participated in Game  
    test_player(1) threw rock, because  
        it is assumed that test_player(1) threw rock  
    test_player(0) participated in Game, because  
        it is assumed that test_player(0) participated in Game  
    test_player(0) threw scissors, because  
        it is assumed that test_player(0) threw scissors  
    rock beats scissors.

ANSWER: 5  
test_player(1) is the winner of Game, because  
    test_player(1) is a player, because  
        'example' holds (for 1).  
    test_player(0) is a player, because  
        'example' holds (for 0).  
    test_player(1) participated in Game, because  
        it is assumed that test_player(1) participated in Game  
    test_player(1) threw scissors, because  
        it is assumed that test_player(1) threw scissors  
    test_player(0) participated in Game, because  
        it is assumed that test_player(0) participated in Game  
    test_player(0) threw paper, because  
        it is assumed that test_player(0) threw paper  
    scissors beats paper.

ANSWER: 6  
test_player(1) is the winner of Game, because  
    test_player(1) is a player, because  
        'example' holds (for 1).  
    test_player(0) is a player, because  
        'example' holds (for 0).  
    test_player(1) participated in Game, because  
        it is assumed that test_player(1) participated in Game  
    test_player(1) threw paper, because  
        it is assumed that test_player(1) threw paper  
    test_player(0) participated in Game, because  
        it is assumed that test_player(0) participated in Game  
    test_player(0) threw rock, because  
        it is assumed that test_player(0) threw rock  
    paper beats rock.
</code></pre><p>If you read the results carefully, 6 results actually makes sense.</p>
<p>Now that we have two concrete players, there is a difference between saying that player(0) beat player(1), and saying that player(1) beat player(0). When we were dealing with players in the abstract, that wasn’t true. So there are three ways to win a game, and two players who might win, for a total of 6 models.</p>
<h3 id=formal-verification-of-draft-legislation>Formal Verification of Draft Legislation</h3>
<p>Now that we have a working encoding, that we can test with any number of players, let’s see what we can find out about the rules to Rock Paper Scissors as we have drafted them.</p>
<p>For instance, we might want to know whether it is possible for all of the players in a game to also be winners of the game. We imagine that we have been told by our clients that this shouldn’t be possible.</p>
<p>Expressing this question in s(CASP) is slightly complicated, because s(CASP) doesn’t have a universal quantifier. So instead of saying “every X is Y”, you need to say “there is no evidence of an X that is not Y”.</p>
<p>So “every game has a loser” becomes “there is no case in which there is a game with no loser. So we first define “there is a loser”, and then we query “it is not true that there is a loser.”</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>loser</span> <span style=color:#f92672>:-</span> <span style=color:#a6e22e>player</span>(P), <span style=color:#a6e22e>player_in_game</span>(P,G), <span style=color:#f92672>not</span> <span style=color:#a6e22e>winner_of_game</span>(P,G).

<span style=color:#e6db74>?-</span> <span style=color:#f92672>not</span> <span style=color:#e6db74>loser</span>.
</code></pre></div><p>It turns out that this query doesn’t work. Why not? Because our definition of <code>loser</code> is “unsafe”. Specifically, in that rule, <code>G</code> is a free variable under negation in the conditions of the rule. That means it does not appear in the conclusion, and it appears as part of a negation in the conditions.</p>
<p>Free variables under negation is a thing that logic programming languages can’t deal with, because “under the hood” it sends the software on a wild goose chase.</p>
<p>We can solve that problem by “grounding” games, making <code>G</code> no longer “free”. Grounding is actually the same thing that we did to players earlier. So we take the exact same steps.</p>
<p>We modify the rule to add a statement that requires that the game exists:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>winner_of_game</span>(Player,Game) :-  
  <span style=color:#a6e22e>game</span>(Game),  
  <span style=color:#a6e22e>player</span>(Player),  
  <span style=color:#a6e22e>player</span>(OtherPlayer),  
  <span style=color:#a6e22e>player_in_game</span>(Player,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(Player,Sign),  
  <span style=color:#a6e22e>player_in_game</span>(OtherPlayer,Game),  
  <span style=color:#a6e22e>player_threw_sign</span>(OtherPlayer,OtherSign),  
  <span style=color:#a6e22e>sign_beats_sign</span>(Sign,OtherSign),  
  Player <span style=color:#e6db74>\=</span> OtherPlayer.
</code></pre></div><p>Then we add a rule to create concrete example game objects, just like we did for players.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>game</span>(<span style=color:#a6e22e>test_game</span>(X)) :- <span style=color:#a6e22e>example</span>(X), <span style=color:#a6e22e>number_of_games</span>(N), X .<span style=color:#e6db74>&lt;.</span> N.
</code></pre></div><p>And then we add a line just above the query to set the number of games.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#a6e22e>number_of_games</span>(<span style=color:#ae81ff>1</span>).
</code></pre></div><p>Now when we run the query, it works, and returns “no models.”</p>
<p>Which means it is never true that there is a game with two players in which there is no player who is not a winner. Which in turn means there is no two-player game where all the players win. Which was the result we wanted.</p>
<h4 id=testing-gives-evidence-formal-verification-gives-proof>Testing gives Evidence, Formal Verification gives Proof</h4>
<p>What we just did was formal verification, not testing. Based on the result we got from the program above, we can say categorically that there is no two player game of Rock Paper Scissors under these rules where all the players win.</p>
<p>The conclusion itself is unimpressive, because the rules are not complicated. What is impressive is that the process is automated, and can be applied to much more complicated problems. Problems beyond the human capacity to analyse in their heads.</p>
<p>Consider a person who wants to know whether the amendments to a tax act increase anyone’s taxes. You can test your encoding, and that will give you scenarios in which it does not. And maybe with enough of those scenarios, and sufficiently representative scenarios, that is sufficient evidence to be reasonably confident that the amendment <em>probably</em> doesn’t increase anyone’s taxes.</p>
<p>But if we can do formal verification as easily as we can do testing, or perhaps even easier, why wouldn’t we?</p>
<h4 id=ngl-its-complicated>NGL, It’s Complicated</h4>
<p>This process, with all the warts included, is an honest representation of the reality of trying to do things like this with s(CASP) at the moment.</p>
<p>It’s not “easy”. But it is, in most cases, “easier” than the alternatives. And if you encode your law in s(CASP) once, you get a tool that can answer many questions. In many non-logical tools, you get a tool that can answer only one. And in many logical tools you do not have the ability to access explanations, or you don’t have the ability to access multiple explanations for the same conclusion, or you don’t have the ability to access explanations for why things are not true, all with no additional coding required.</p>
<p>So the return on investment for s(CASP) in Rules as Code is higher than for many other tools, and grows exponentially with the complexity of the law, and how frequently it needs to be updated.</p>
<p>But high ROI doesn’t mean the investment is low.</p>
<p>Unfortunately, because of bugs in s(CASP), and because of the sometimes combinatorially-explosive nature of logic programming, and because of quirks of the operational semantics of logic programming like free variables under negation, there will be things that just don’t work, or don’t work fast enough. When that happens, you need to reformulate your code to create an equivalent version that will answer the same question.</p>
<p>So the bad news is that right now, using s(CASP) and similar tools effectively requires a lot of learning, and that learning is difficult to obtain. My passion is reducing the amount of learning required, making the remaining learning as easy to achieve as possible, and demonstrating the potential of the approach so that people will help.</p>
<h3 id=speaking-of-bugs>Speaking of Bugs…</h3>
<p>What happens if we change the number of players the model knows about to 3?</p>
<p>If we set <code>number_of_players(3).</code> and query <code>not loser</code>, the software goes into an infinite loop. (I’m pretty sure. I didn’t actually wait for infinity to find out.) Which probably means that there is a bug in s(CASP) somewhere, but it also suggests that this is not as simple a question as when the number of players was 1.</p>
<p>As a work-around, we can try to find a counter example ourselves with a more complicated query. Instead of querying <code>not loser</code>, we can directly write a query that means “is there a scenario in which there are three different players, each of which is the winner of the same game?”</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=color:#e6db74>?-</span> <span style=color:#a6e22e>player</span>(A), <span style=color:#a6e22e>player</span>(B), <span style=color:#a6e22e>player</span>(C), A <span style=color:#e6db74>\=</span> B, B <span style=color:#e6db74>\=</span> C, C <span style=color:#e6db74>\=</span> A, <span style=color:#a6e22e>winner_of_game</span>(A,Game), <span style=color:#a6e22e>winner_of_game</span>(B,Game), <span style=color:#a6e22e>winner_of_game</span>(C,Game).
</code></pre></div><p>If we run this query with the above code in the usual way, we discover a different version of what is probably the same bug… s(CASP) instantly starts printing out a (seemingly) infinite list of scenarios in which this is true.</p>
<p>We can work around that version of the problem by telling s(CASP) we are only interested in one answer, by saying <code>-s1</code> in the command line. If we do that, here’s the first answer we get:</p>
<pre tabindex=0><code>QUERY:I would like to know if  
     A is a player and  
     B is a player and  
     C is a player and  
     A is not equal B and  
     B is not equal C and  
     C is not equal A and  
     A is the winner of Game and  
     B is the winner of Game and  
     C is the winner of Game.

ANSWER: 1  
test_player(0) is a player, because  
    'example' holds (for 0), and  
    'number_of_players' holds (for 3).  
test_player(1) is a player, because  
    'example' holds (for 1), and  
    'number_of_players' holds (for 3).  
test_player(2) is a player, because  
    'example' holds (for 2), and  
    'number_of_players' holds (for 3).  
test_player(0) is the winner of test_game(0), because  
    test_game(0) is a game, because  
        'example' holds (for 0), and  
        'number_of_games' holds (for 1).  
    test_player(0) is a player, justified above, and  
    test_player(1) is a player, because  
        'example' holds (for 1), and  
        'number_of_players' holds (for 3).  
    test_player(0) participated in test_game(0), because  
        it is assumed that test_player(0) participated in test_game(0)  
    test_player(0) threw rock, because  
        it is assumed that test_player(0) threw rock  
    test_player(1) participated in test_game(0), because  
        it is assumed that test_player(1) participated in test_game(0)  
    test_player(1) threw scissors, because  
        it is assumed that test_player(1) threw scissors  
    rock beats scissors.  
test_player(1) is the winner of test_game(0), because  
    test_game(0) is a game, justified above, and  
    test_player(1) is a player, justified above, and  
    test_player(0) is a player, because  
        'example' holds (for 0), and  
        'number_of_players' holds (for 3).  
    test_player(1) participated in test_game(0), justified above, and  
    test_player(1) threw rock, because  
        it is assumed that test_player(1) threw rock  
    test_player(0) participated in test_game(0), justified above, and  
    test_player(0) threw scissors, because  
        it is assumed that test_player(0) threw scissors  
    rock beats scissors.  
test_player(2) is the winner of test_game(0), because  
    test_game(0) is a game, justified above, and  
    test_player(2) is a player, justified above, and  
    test_player(0) is a player, because  
        'example' holds (for 0), and  
        'number_of_players' holds (for 3).  
    test_player(2) participated in test_game(0), because  
        it is assumed that test_player(2) participated in test_game(0)  
    test_player(2) threw rock, because  
        it is assumed that test_player(2) threw rock  
    test_player(0) participated in test_game(0), justified above, and  
    test_player(0) threw scissors, because  
        it is assumed that test_player(0) threw scissors  
    rock beats scissors.
</code></pre><p>So you can see, if there are three players, and each of them throws a different sign, it is possible for there to be no losers, and for everyone to be a winner according to our rules.</p>
<p>Whoops!</p>
<h3 id=back-to-the-legislative-drafting-board>Back to the (Legislative) Drafting Board</h3>
<p>So what we learn from this formal verification exercise is that our draft law has a bug when the number of players goes to 3. Further testing would reveal that there is no winner of a 1-player game under these rules, either.</p>
<p>Now we would revise, and go back to our client seeking instructions for how they want ties, and one-player games to be treated, etc. We come up with new ideas for the rules, encode those, re-run the verifications, lather, rinse, and repeat.</p>
<p>Eventually, maybe our draft act looks something like this:</p>
<blockquote>
<ol>
<li>The winner of a game of rock paper scissors is:</li>
</ol>
</blockquote>
<blockquote>
<p>a) a player in that game, if they are the only player in that game, or</p>
</blockquote>
<blockquote>
<p>b) a player whose sign beats the signs of all other players in that game, or</p>
</blockquote>
<blockquote>
<p>c) the winner of a new run-off game among the players whose sign was not beaten by any other player, or</p>
</blockquote>
<blockquote>
<p>d) the winner of a run-off game of rock paper scissors among players in a tied game.</p>
</blockquote>
<blockquote>
<ol start=2>
<li>A game of rock paper scissors is tied if:</li>
</ol>
</blockquote>
<blockquote>
<p>a) all players throw the same sign, or</p>
</blockquote>
<blockquote>
<p>b) all players throw a sign that is defeated by a sign thrown by another player, and that defeats a sign thrown by another player.</p>
</blockquote>
<blockquote>
<ol start=3>
<li>Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.</li>
</ol>
</blockquote>
<p>Encoding and formal verification in a Rules as Code process with tools like s(CASP) can make it easier to learn more about how the rules you wrote actually behave. That in turn makes it easier to find places they do not behave as expected, ways to make them behave as expected, and areas where you are not certain what behaviour was intended.</p>
<p>These are not new ideas. All of these things are being done, right now, as a part of every legislative drafting effort. The only difference is that they are being done by people, <em>without the help of computers</em>.</p>
<p>If we can give drafters that help, we make it easier to get better laws that are easier to automate, and the downstream effects of that for fairness, consistency, efficiency, and access to justice are enormous.</p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
<p class="f5 b mb3">What's in this post</p>
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href=#the-draft>The Draft</a></li>
<li><a href=#the-procedure>The Procedure</a></li>
<li><a href=#first-iteration>First Iteration</a></li>
<li><a href=#second-iteration>Second Iteration</a></li>
<li><a href=#third-iteration>Third Iteration</a></li>
<li><a href=#fourth-iteration>Fourth Iteration</a></li>
<li><a href=#an-aside>An Aside</a></li>
<li><a href=#fifth-iteration>Fifth Iteration</a></li>
<li><a href=#a-wrinkle-or-two>A Wrinkle or Two</a>
<ul>
<li><a href=#making-disunity-explicit>Making Disunity Explicit</a></li>
<li><a href=#quickly-generating-instances>Quickly Generating Instances</a></li>
</ul>
</li>
<li><a href=#formal-verification-of-draft-legislation>Formal Verification of Draft Legislation</a>
<ul>
<li><a href=#testing-gives-evidence-formal-verification-gives-proof>Testing gives Evidence, Formal Verification gives Proof</a></li>
<li><a href=#ngl-its-complicated>NGL, It’s Complicated</a></li>
</ul>
</li>
<li><a href=#speaking-of-bugs>Speaking of Bugs…</a></li>
<li><a href=#back-to-the-legislative-drafting-board>Back to the (Legislative) Drafting Board</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
<div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
<p class="f5 b mb3">Related</p>
<ul class="pa0 list">
<li class=mb2>
<a href=/post/roundtablelaw/open-source-legal-expert-systems-video-3m-b57bcde7f490/>Open Source Legal Expert Systems Video (3m)</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/introducing-l4-docassemble-69ce4b1fb1e7/>Introducing L4-Docassemble</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/legal-drafting-to-avoid-computational-complexity-115a55818493/>Legal Drafting to Avoid Computational Complexity</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/modelling-the-world-the-law-and-the-question-e24ea763120e/>Modelling the World, the Law, and the Question</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/and-why-it-matters-for-rules-as-code-8610e49511c8/>… and why it matters for Rules as Code</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/what-is-justified-stable-model-constraint-query-driven-answer-set-programming-c895955bf68c/>What is Justified Stable Model Constraint Query-Driven Answer Set Programming?</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/s-casp-as-a-rules-as-code-tool-97ec3435975c/>s(CASP) as a Rules as Code Tool</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/computational-law-diary-encoding-covid-19-rules-using-basic-event-calculus-in-s-casp-32a55b789eeb/>Encoding Covid-19 rules using Basic Event Calculus in s(CASP)</a>
</li>
<li class=mb2>
<a href=/post/roundtablelaw/computational-law-diary-explainable-legal-ai-in-s-casp-19da0a5d956/>Explainable Legal AI in s(CASP)</a>
</li>
</ul>
</div>
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://JasonMorrisSC.github.io>
&copy; Jason Morris 2022
</a>
<div>
<div class=ananke-socials>
<a href=https://twitter.com/RoundTableLaw target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window">
<span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:{{ .fill }}"/></svg>
</span>
<span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</span></a>
</div></div>
</div>
</footer>
</body>
</html>