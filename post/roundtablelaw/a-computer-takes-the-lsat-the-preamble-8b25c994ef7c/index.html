<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>A Computer Takes the LSAT: The Preamble | Jason Morris</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="This is the second in a series of posts demonstrating how to encode LSAT Puzzle questions in the Ergo Lite programming language. To start…"><meta name=generator content="Hugo 0.94.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="A Computer Takes the LSAT: The Preamble"><meta property="og:description" content="This is the second in a series of posts demonstrating how to encode LSAT Puzzle questions in the Ergo Lite programming language. To start…"><meta property="og:type" content="article"><meta property="og:url" content="https://JasonMorrisSC.github.io/post/roundtablelaw/a-computer-takes-the-lsat-the-preamble-8b25c994ef7c/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-04-25T21:51:42+00:00"><meta property="article:modified_time" content="2019-04-25T21:51:42+00:00"><meta itemprop=name content="A Computer Takes the LSAT: The Preamble"><meta itemprop=description content="This is the second in a series of posts demonstrating how to encode LSAT Puzzle questions in the Ergo Lite programming language. To start…"><meta itemprop=datePublished content="2019-04-25T21:51:42+00:00"><meta itemprop=dateModified content="2019-04-25T21:51:42+00:00"><meta itemprop=wordCount content="2222"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="A Computer Takes the LSAT: The Preamble"><meta name=twitter:description content="This is the second in a series of posts demonstrating how to encode LSAT Puzzle questions in the Ergo Lite programming language. To start…"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Jason Morris</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="About Jason page">About Jason</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/project/ title="Projects page">Projects</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/post/ title="Rules as Code Diary page">Rules as Code Diary</a></li></ul><div class=ananke-socials><a href=https://twitter.com/RoundTableLaw target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:{{ .fill }}"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">RULES AS CODE DIARY</aside><div id=sharing class="mt3 ananke-socials"><a href="https://twitter.com/share?url=https://JasonMorrisSC.github.io/post/roundtablelaw/a-computer-takes-the-lsat-the-preamble-8b25c994ef7c/&text=A%20Computer%20Takes%20the%20LSAT:%20The%20Preamble" class="ananke-social-link twitter no-underline" aria-label="share on Twitter"><span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:{{ .fill }}"/></svg></span></a></div><h1 class="f1 athelas mt3 mb1">A Computer Takes the LSAT: The Preamble</h1><time class="f6 mv4 dib tracked" datetime=2019-04-25T21:51:42Z>April 25, 2019</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>This is the second in a series of posts demonstrating how to encode LSAT Puzzle questions in the Ergo Lite programming language. To start from the beginning, <a href=https://medium.com/@jason_90344/a-computer-takes-the-lsat-introduction-3a65fd8b982>go to the introductory post</a>.</p><p>In this post, we will encode the “preamble” to the section of questions. These are the basic rules that apply to all of the following questions. By analogy to automating legal services, these rules represent statute law or regulations.</p><p>The preamble reads as follows:</p><blockquote><p>Exactly three films-Greed, Harvest, and Limelight-are shown during a film club’s festival held on Thursday, Friday, and Saturday. Each film is shown at least once during the festival but never more than once on a given day. On each day at least one film is shown. Films are shown one at a time. The following conditions apply:</p></blockquote><blockquote><ul><li>On Thursday Harvest is shown, and no film is shown after it on that day.</li></ul></blockquote><blockquote><ul><li>On Friday either Greed or Limelight, but not both, is shown, and no film is shown after it on that day.</li></ul></blockquote><blockquote><ul><li>On Saturday either Greed or Harvest, but not both, is shown, and no film is shown after it on that day.</li></ul></blockquote><p>So the first thing that we need to do is we need to tell the software about the types of objects that exist in our problem domain. Which objects to encode and how are up to the person doing the encoding, but here’s how I approached it.</p><p>First, there is a type of object called a Film, and we know the names of all three of the possible films. In Ergo Lite, the <code>:</code> character means “is a”, and allows you to specify the object type of names that you provide to the code. So to say that Greed, Harvest, and Limelight are all films, we write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>Greed<span style=color:#e6db74>:</span>Film.  
</span></span><span style=display:flex><span>Harvest<span style=color:#e6db74>:</span>Film.  
</span></span><span style=display:flex><span>Limelight<span style=color:#e6db74>:</span>Film.
</span></span></code></pre></div><p>You will notice that all of the “sentences” in Ergo Lite end with a period.</p><p>Ergo Lite allows you to use a set of names as a shortcut to typing the same thing out over and over, which we will do to specify that Thursday, Friday, and Saturday are the possible days for a festival.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>{Thursday, Friday, Saturday}<span style=color:#e6db74>:</span>Day.
</span></span></code></pre></div><p>Now, I’m going to say that a “schedule” is one or more screenings. Here I will use Ergo Lite’s syntax for creating an abstract type of object, like a blank form, and saying what fields exist on that form.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>Schedule[|<span style=color:#e6db74>screenings=&gt;</span>Screening|].
</span></span></code></pre></div><p>So here I have said that “Schedule” is a type of object, and that type of object has one or more “screenings”, each of which is a “Screening” object.</p><p>Now I need to describe what a Screening is. I will say that a Screening is a film, shown on a day, in a certain time slot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>Screening[|<span style=color:#e6db74>film=&gt;</span>Film,<span style=color:#e6db74>day=&gt;</span>Day,<span style=color:#e6db74>slot=&gt;</span>Slot|].
</span></span></code></pre></div><p>We have already given information about films, and days, so now I need to describe a slot. We need slots in order to figure out whether films are being shown before, after, or at the same time as one another. I will say that a slot might be first, second, or third.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>{First,Second,Third}<span style=color:#e6db74>:</span>Slot.
</span></span></code></pre></div><p>Several of the rules in the preamble make use of the criteria “after”. This is the sort of thing that is implicitly understood by people reading legislation, but which needs to be explicitly explained to the computer. So I will say that a Slot object has an attribute “after”, which is a list of one or more other Slots that the current slot is after. And then, I will populate that attribute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>Slot[|<span style=color:#e6db74>after=&gt;</span>Slot|].  
</span></span><span style=display:flex><span>Second[<span style=color:#e6db74>after-&gt;</span>First].  
</span></span><span style=display:flex><span>Third[<span style=color:#e6db74>after-&gt;</span>First,<span style=color:#e6db74>after-&gt;</span>Second].
</span></span></code></pre></div><p>Now I need to be able to distinguish between a schedule that follows the rules and one that doesn’t. So I will use the <code>::</code> operator, which means “is a type of”, so say that a ValidSchedule is a type of Schedule.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span>ValidSchedule<span style=color:#e6db74>::</span>Schedule.
</span></span></code></pre></div><p>This means that a ValidSchedule also has all of the parts of a schedule, which is a list of screenings, where each screening is a film, a day, and a slot.</p><p>That sets out the ontology of our question, the objects that exist and how they relate to one another. Now we need to set out the rules, and you can see that there are a number of them in the preamble. We will encode each, one by one.</p><p>A rule uses the basic structure <code>head :- body</code>. The head is known to be true if the body can be proved. It is similar to saying <code>if body then head</code> , except that in a declarative programming language the word “then” does not mean “next.” Instead, it means <code>if we know body is true then we know head is true</code>.</p><p>So we will start with a rule that defines what makes a ValidSchedule. The head of my rule says “something, called X, is a ValidSchedule”. The body says “if it is a schedule and these things are true about it.”</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?</span>x:ValidSchedule :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>each_film_at_least_once-&gt;\true</span>,   
</span></span><span style=display:flex><span>        <span style=color:#e6db74>\naf</span> <span style=color:#e6db74>film_twice_same_day-&gt;\true</span>,   
</span></span><span style=display:flex><span>        <span style=color:#e6db74>at_least_one_film_per_day-&gt;\true</span>,   
</span></span><span style=display:flex><span>        <span style=color:#e6db74>\naf</span> <span style=color:#e6db74>more_than_one_film_at_a_time-&gt;\true</span>,  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>thursday_rule-&gt;\true</span>,  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>friday_rule-&gt;\true</span>,  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>saturday_rule-&gt;\true</span>  
</span></span><span style=display:flex><span>    ].
</span></span></code></pre></div><p>You’re going to see <code>\naf</code> a lot in the code. It stands for “negation as failure”, and it is a type of negation. The specifics are not important for now. You can read <code>\naf</code> as “it is not true that”.</p><p>You will also notice the commas at the end of the lines. In Ergo Lite the comma <code>,</code> means “and”. The things on both sides of the comma must be true for the statement to be true.</p><p>You can see that I have taken the 7 rules about a valid schedule from the pre-amble, and made each of them a property of a Schedule object that might be true or false.</p><p>Now we need to explain to the software how to determine whether each of those factors is true.</p><p>First, whether each film is shown at least once. Intuitively, it is true that each film was shown at least once if there is at least one screening in a schedule for each of the three films. So we can ask, once for each film, whether there is any screening of that film.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>each_film_at_least_once-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y1:</span>Screening[<span style=color:#e6db74>film-&gt;</span>Greed]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y2:</span>Screening[<span style=color:#e6db74>film-&gt;</span>Harvest]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y3:</span>Screening[<span style=color:#e6db74>film-&gt;</span>Limelight]].
</span></span></code></pre></div><p>When you use the same variable name like <code>?x</code> multiple times in a rule, you are referring to the same object. If you use different variable names like <code>?_y1</code> and <code>?_y2</code>, you might be referring to the same object, or to a different object. Inserting an underscore after the question mark in the variable name tells the code that you are only interested in whether there is an object that matches, you are not interested in knowing it’s name.</p><p>So, this rule can be read as follows:</p><blockquote><p>An object, called X, has the attribute “each film at least once” set to true if it can be shown that:</p></blockquote><blockquote><p>That object X has a screening object y1, and that object y1 is for the film Greed, and</p></blockquote><blockquote><p>That object X has a screening object y2, and that object y2 is for the film Harvest, and</p></blockquote><blockquote><p>That object X has a screening object y3, and that object y3 is for the film Limelight.</p></blockquote><p>Next we need to encode the rule that films are not supposed to be shown more than once on the same day. We defined ValidSchedule above as a situation in which this is not true. So here we need to define when it is true.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>film_twice_same_day-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span>y:Screening[<span style=color:#e6db74>film-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>yf</span>,<span style=color:#e6db74>day-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>day</span>]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?x</span>[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span>z:Screening[<span style=color:#e6db74>film-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>yf</span>,<span style=color:#e6db74>day-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>day</span>]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y</span> !<span style=color:#f92672>==</span> <span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>z</span>.
</span></span></code></pre></div><p>So here, the body of the rule can be read as follows:</p><p>“If an object X is a Schedule, and it has a screening called Y, and Y is a screening, and Y has a film called YF, and a day called DAY; and the object X has a screening Z that is a screening and its film is also YF and its day is also DAY, and Y and Z are not the same object.”</p><p>So we have asked it whether there is a schedule X that has two screenings, Y and Z, where Y and Z are for the same film on the same day, and they are not the same object.</p><p>We need to say explicitly that Y and Z can’t be the same object, because that is not implicit in the names. It can be true that “object x has a screening y” and “object x has a screening z” even if x only has one screening. We have just given that one screening two names.</p><p>That is because when you use the same variable name twice, you are referring to the same object. When you use different variable names, you MAY still be referring to the same object, but you might not. You need to check, if it’s important.</p><p>The next rule is that on each day at least one film is shown. So we can encode that rule as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>at_least_one_film_per_day-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y1:</span>Screening[<span style=color:#e6db74>day-&gt;</span>Thursday]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y2:</span>Screening[<span style=color:#e6db74>day-&gt;</span>Friday]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y3:</span>Screening[<span style=color:#e6db74>day-&gt;</span>Saturday]].
</span></span></code></pre></div><p>The next rule is that only one film is shown at a time. Again, we have negated this rule in the definition of a valid schedule, so here we need to figure out what makes it true. It is true if there are two different screenings on the same day and with the same slot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>more_than_one_film_at_a_time-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y</span>[<span style=color:#e6db74>day-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>yd</span>,<span style=color:#e6db74>slot-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>ys</span>]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>z</span>[<span style=color:#e6db74>day-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>yd</span>,<span style=color:#e6db74>slot-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>ys</span>]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>y</span> !<span style=color:#f92672>==</span> <span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>z</span>.
</span></span></code></pre></div><p>Now we are left with the rules about a valid Thursday, Friday, and Saturday schedule. The rule for Thurdsay is that harvest must be shown, and it must be shown last.</p><p>As it happens “last” is something that we are going to use more later, so it is useful for us to encode the meaning of “last” separately. We will say that a Schedule has a function called last. If you give that function the name of a day, it will return the name of the film that is shown last on that day.</p><p>This will allow us to use the short hand <code>?x[last(Friday)->?film]</code> when we need to refer, for example, to the last film on Friday.</p><p>So here, the head of our rule describes the function, and the body of our rule calculates it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#a6e22e>last</span>(<span style=color:#e6db74>?day</span>)<span style=color:#e6db74>-&gt;?film</span>] :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>[<span style=color:#e6db74>day-&gt;?day</span>,<span style=color:#e6db74>slot-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>slot</span>,<span style=color:#e6db74>film-&gt;?film</span>]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>\naf</span> <span style=color:#e6db74>?x</span>[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>os</span>[<span style=color:#e6db74>day-&gt;?day</span>,<span style=color:#e6db74>slot-&gt;?</span><span style=color:#66d9ef>_</span>[<span style=color:#e6db74>after-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>slot</span>]]].
</span></span></code></pre></div><p>So this reads as follows:</p><p>“We know that a film called FILM is the last film of day called DAY in a object called X when we can prove that X is a Schedule with a screening s, which has a day, slot, and film; and it is not true that there is a screening OS in schedule x with the same day, and a slot that is after S’s slot.”</p><p>Here we do not need to say explicitly that S and OS are different objects, because we have already said that OS would need to have a slot that is after the slot for S.</p><p>Remember that we defined the property “after” for slots above.</p><p>So now we have a way of referring to the last film on a given day.</p><p>Let’s go back to the rule for Thursdays.. Harvest must be shown, and it must be shown last. We already know that Harvest must be shown once per festival, but there is no guarantee that it is being shown on Thursday, so we need to check to see if harvest is shown on Thursday, and if it is last on Thursday.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>thursday_rule-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>[<span style=color:#e6db74>day-&gt;</span>Thursday,<span style=color:#e6db74>film-&gt;</span>Harvest]],  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>?x</span>[<span style=color:#a6e22e>last</span>(Thursday)<span style=color:#e6db74>-&gt;</span>Harvest].
</span></span></code></pre></div><p>The rule for Fridays is that either Greed or Limelight is shown, but not both, and whichever is shown is shown last. So we need to look at two possibilities, either Greed is shown last on Friday (in which case we know it was shown, and nothing was shown after it) and Limelight isn’t shown, or Limelight is shown last on Friday and Greed isn’t shown.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>friday_rule-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    ( <span style=color:#f92672>//</span> <span style=color:#e6db74>either</span>  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#a6e22e>last</span>(Friday)<span style=color:#e6db74>-&gt;</span>Greed],  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>\naf</span> <span style=color:#a6e22e>exists</span>(<span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>)<span style=color:#e6db74>^?x</span>[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>[<span style=color:#e6db74>film-&gt;</span>Limelight,<span style=color:#e6db74>day-&gt;</span>Friday]]  
</span></span><span style=display:flex><span>    ) <span style=color:#e6db74>\</span><span style=color:#a6e22e>or</span> (  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#a6e22e>last</span>(Friday)<span style=color:#e6db74>-&gt;</span>Limelight,<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>],  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>\naf</span> <span style=color:#a6e22e>exists</span>(<span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>)<span style=color:#e6db74>^?x</span>[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>[<span style=color:#e6db74>film-&gt;</span>Greed,<span style=color:#e6db74>day-&gt;</span>Friday]]  
</span></span><span style=display:flex><span>    ).
</span></span></code></pre></div><p>Here you can see the <code>\or</code> command separates the two sets of possibilities, that are surrounded by parentheses. Each option (Greed and no Limelight, or Limelight and no Greed), is structured as two conditions. First, the film we are looking for was shown in a given schedule. Second, there are no screenings for that show for other film.</p><p>This second condition is expressed as <code>\naf exists(?_s)^?x[screenings->?_s[film->Limelight,day->Friday]]</code>. You might be wondering why we need the <code>exists(?_s)^</code> syntax in there. The reason is that <code>\naf ?x</code> in Ergo Lite means exists(not(?x)). Or put another way “is there an object in the database for which the value of ?x is false”. But you don’t want to know whether there is a screening that is not Limelight on Friday. What you want to know is whether it is true that there are no screenings of Limelight on Friday, or not(exists(?x)). For that sort of query, you need to be explicit about where the existential qualifier goes.</p><p>We will use the exact same structure for the Saturday rule, which requires that either Greed or Harvest is shown last, and the other isn’t shown.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#e6db74>?x</span>[<span style=color:#e6db74>saturday_rule-&gt;\true</span>] :-  
</span></span><span style=display:flex><span>    ( <span style=color:#f92672>//</span> <span style=color:#e6db74>either</span>  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#a6e22e>last</span>(Saturday)<span style=color:#e6db74>-&gt;</span>Greed],  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>\naf</span> <span style=color:#a6e22e>exists</span>(<span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>)<span style=color:#e6db74>^?x</span>[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>[<span style=color:#e6db74>film-&gt;</span>Harvest,<span style=color:#e6db74>day-&gt;</span>Saturday]]  
</span></span><span style=display:flex><span>    ) <span style=color:#e6db74>\</span><span style=color:#a6e22e>or</span> (  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>?</span>x:Schedule[<span style=color:#a6e22e>last</span>(Saturday)<span style=color:#e6db74>-&gt;</span>Harvest],  
</span></span><span style=display:flex><span>        <span style=color:#e6db74>\naf</span> <span style=color:#a6e22e>exists</span>(<span style=color:#e6db74>?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>)<span style=color:#e6db74>^?x</span>[<span style=color:#e6db74>screenings-&gt;?</span><span style=color:#66d9ef>_</span><span style=color:#e6db74>s</span>[<span style=color:#e6db74>film-&gt;</span>Greed,<span style=color:#e6db74>day-&gt;</span>Saturday]]  
</span></span><span style=display:flex><span>    ).
</span></span></code></pre></div><p>That’s it. We have encoded the pre-amble. In the <a href=https://medium.com/@jason_90344/a-computer-takes-the-lsat-generating-fact-scenarios-3a52fd6fe908>next installment</a>, I will show you how you can use Ergo Lite to generate all possible Valid Schedules.</p><p>Jason Morris is an LLM Candidate in Computational Law at the University of Alberta Faculty of Law, the operator of <a href=https://www.roundtablelaw.ca>Round Table Law</a>, and co-founder of <a href=https://www.lemmalegal.com>Lemma Legal Consulting</a>. He can be reached at <a href=https://www.twitter.com/RoundTableLaw>@RoundTableLaw</a> on Twitter. If you need help getting computers to do law, feel free to get in touch.</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">What's in this post</p><nav id=TableOfContents></nav></div><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/post/roundtablelaw/a-computer-takes-the-lsat-introduction-3a65fd8b982/>A Computer Takes the LSAT: Introduction</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://JasonMorrisSC.github.io>&copy; Jason Morris 2022</a><div><div class=ananke-socials><a href=https://twitter.com/RoundTableLaw target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:{{ .fill }}"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></div></footer></body></html>